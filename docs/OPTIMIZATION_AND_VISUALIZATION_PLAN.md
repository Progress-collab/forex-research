# План улучшения оптимизации и визуализации результатов

## Анализ текущих результатов оптимизации

### 1.1 Анализ результатов momentum_breakout
- Лучший Profit Factor: 0.239 (все еще < 1.0)
- Лучшие параметры: atr_multiplier=2.5, adx_threshold=25, lookback_hours=20, confirmation_bars=3, min_pos_di_advantage=3.0
- Проанализировать распределение результатов всех 576 комбинаций
- Выявить паттерны в лучших комбинациях параметров
- Определить, какие параметры наиболее критичны
- Создать heatmap распределения результатов по параметрам

### 1.2 Тестирование лучших параметров
- Запустить бэктест с оптимизированными параметрами на полных данных
- Сравнить с базовыми параметрами
- Проверить метрики: Profit Factor, Recovery Factor, Sharpe Ratio
- Визуализировать сделки с лучшими параметрами

## Улучшение оптимизации

### 2.1 Добавление параллелизации CPU (приоритет 1)
- Использовать `multiprocessing` или `concurrent.futures` для параллельного выполнения бэктестов
- Распараллелить по ядрам процессора (4-8 потоков)
- Ожидаемое ускорение: 4-8x для grid search
- Обновить `HyperparameterOptimizer.optimize()` для поддержки `n_jobs` параметра
- Обработать проблемы с pickle для стратегий (если возникнут)
- Добавить прогресс-бар для отслеживания выполнения

### 2.2 Добавление поддержки GPU (приоритет 2)
- Исследовать использование GPU для параллельных вычислений
- Варианты: CuPy, Numba CUDA, или PyTorch для параллельных вычислений
- Основная сложность: бэктесты не очень подходят для GPU (много условной логики)
- Возможное применение: параллельные вычисления индикаторов для множества комбинаций параметров
- Добавить опцию `--use-gpu` в скрипт оптимизации
- Проверить наличие CUDA/ROCm перед использованием
- Создать fallback на CPU если GPU недоступен

### 2.3 Добавление облачных вычислений (приоритет 3)
- Исследовать бесплатные варианты облачных вычислений:
  - Google Colab (бесплатный GPU, ограничения по времени)
  - Kaggle Kernels (бесплатный GPU, ограничения)
  - GitHub Actions (бесплатно для публичных репозиториев, ограничения)
  - AWS Free Tier (ограниченный)
- Создать скрипт для отправки задач оптимизации в облако
- Использовать очереди задач (Redis, RabbitMQ) или простой файловый обмен через S3/GitHub
- Добавить поддержку распределенной оптимизации через облако
- Создать инструкцию по настройке облачных вычислений
- Реализовать автоматическую загрузку результатов обратно

### 2.4 Добавление генетического алгоритма (приоритет 4) ✅ РЕАЛИЗОВАНО
- Реализован генетический алгоритм для оптимизации параметров
- Используется библиотека `deap` (>=1.4.1)
- Преимущества: быстрее для больших пространств параметров, может найти лучшие решения
- Добавлен класс `GeneticOptimizer` в `src/backtesting/genetic_optimization.py`
- Генетический алгоритм работает параллельно на CPU
- Параметры GA по умолчанию:
  - Поколений: 20
  - Размер популяции: 50
  - Вероятность мутации: 0.2
  - Вероятность скрещивания: 0.7
  - Селекция: tournament selection (размер турнира: 3)
  - Элитизм: сохраняет топ-5 лучших особей
- Использование:
  - CLI: `python scripts/optimize_strategy.py --strategy carry_momentum --use-genetic`
  - В коде: `optimize_carry_momentum_genetic(runner, instrument, period)`
- Совместимость: использует тот же формат `OptimizationResult` что и grid search
- Кэширование: использует тот же кэш результатов что и grid search для избежания повторных вычислений

### 2.5 Сохранение полных результатов
- Сохранять все результаты оптимизации (all_results) в JSON для анализа
- Создать скрипт для анализа распределения результатов
- Визуализировать результаты оптимизации (heatmap параметров, распределение scores)
- Сохранять результаты в структурированном формате для последующего анализа

### 2.6 Дополнительные методы ускорения оптимизации
- Раннее прекращение (early stopping): останавливать оптимизацию комбинации параметров, если текущий результат явно хуже лучшего (например, если после N баров Profit Factor < 0.5 от текущего лучшего)
- Адаптивный grid search: начинать с крупной сетки (например, шаг 2x), затем сужать область поиска вокруг лучших результатов (шаг 0.5x)
- Байесовская оптимизация: использовать библиотеку `scikit-optimize` или `optuna` для интеллектуального поиска оптимальных параметров вместо полного перебора
- Кэширование результатов: сохранять результаты бэктестов для одинаковых комбинаций параметров в файловый кэш или базу данных
- Уменьшение размера данных для быстрой оценки: использовать меньший период данных (например, 1 месяц) для первоначальной оценки всех комбинаций, затем полные данные для топ-10 лучших кандидатов
- Иерархическая оптимизация: сначала оптимизировать критичные параметры (ATR multiplier, ADX threshold), затем второстепенные (confirmation_bars, min_pos_di_advantage)
- Использование приближенных метрик: использовать быстрые метрики (например, win rate * avg_win / avg_loss) для фильтрации, затем точные метрики (Profit Factor) для финальной оценки

## Визуализация результатов

### 3.1 Расширенная визуализация сделок на графике
- Создать скрипт `scripts/visualize_trades.py` для визуализации сделок
- Отобразить ценовой график (свечи/линия) с временной осью
- Отобразить точки входа:
  - Зеленые маркеры для LONG позиций
  - Красные маркеры для SHORT позиций
- Отобразить точки выхода:
  - Синие маркеры для прибыльных сделок
  - Оранжевые маркеры для убыточных сделок
- Нарисовать линии между входом и выходом:
  - Зеленые линии для прибыльных сделок
  - Красные линии для убыточных сделок
  - Толщина линии может отражать размер позиции или прибыль
- Отобразить стоп-лоссы:
  - Горизонтальная линия от точки входа до точки выхода (если сработал стоп)
  - Красная пунктирная линия для стоп-лосса
  - Если стоп-лосс трейлится, показать изменение линии стоп-лосса во времени
  - Отобразить траекторию trailing stop как ступенчатую линию с временными метками
- Отобразить тейк-профиты:
  - Горизонтальная линия от точки входа до точки выхода (если сработал тейк)
  - Зеленая пунктирная линия для тейк-профита
  - Если тейк-профит изменяется со временем, показать изменение линии
- Отобразить частичное закрытие:
  - Показать момент частичного закрытия позиции
  - Изменить размер линии после частичного закрытия
- Использовать matplotlib или plotly для интерактивных графиков
- Сохранять графики в PNG/SVG/HTML для анализа
- Добавить легенду и аннотации с информацией о сделках

### 3.2 Модификация бэктестера для отслеживания изменений стоп-лоссов и тейк-профитов
- Модифицировать `_simulate_trade` для сохранения истории изменения стоп-лосса и тейк-профита
- Сохранять временные метки и значения стоп-лосса/тейк-профита на каждом баре
- Добавить структуру `StopTakeHistory` для хранения истории изменений
- Добавить эту информацию в структуру Trade для последующей визуализации
- Сохранять информацию о частичном закрытии и изменении размера позиции

### 3.3 Интеграция визуализации в оптимизацию
- Автоматически генерировать график для лучших параметров после оптимизации
- Сохранять график вместе с результатами оптимизации в `research/configs/optimized/`
- Добавить опцию `--visualize` в скрипт оптимизации
- Создать функцию для визуализации конкретной сделки или всех сделок стратегии
- Добавить возможность фильтрации сделок для визуализации (только прибыльные, только убыточные, по дате)

## Следующие шаги оптимизации

### 4.1 Оптимизация других стратегий
- Запустить оптимизацию для carry_momentum (240 комбинаций) с использованием параллелизации
- Запустить оптимизацию для combined_momentum (если показывает потенциал)
- Использовать параллелизацию для ускорения всех оптимизаций

### 4.2 Анализ убыточных сделок с оптимизированными параметрами
- Запустить `analyze_losing_trades.py` с лучшими параметрами
- Сравнить паттерны убыточных сделок до и после оптимизации
- Выявить, улучшились ли условия входа
- Визуализировать убыточные сделки для анализа

### 4.3 Walk-forward валидация
- Провести walk-forward валидацию для оптимизированных стратегий
- Проверить стабильность параметров на out-of-sample данных
- Оценить деградацию производительности
- Визуализировать результаты walk-forward валидации

## Поиск новых стратегий (если текущие не улучшаются)

### 6.1 Критерии для перехода к новым стратегиям
- Если после оптимизации всех текущих стратегий Profit Factor < 1.0 для всех
- Если Recovery Factor < 1.5 для всех стратегий после оптимизации
- Если walk-forward валидация показывает деградацию > 50%
- Если анализ показывает фундаментальные проблемы в логике стратегий

### 6.2 Исследование альтернативных подходов
- Изучить успешные стратегии из литературы и open-source проектов
- Рассмотреть стратегии на основе:
  - Order flow analysis (анализ потока ордеров)
  - Market microstructure (микроструктура рынка)
  - Multi-timeframe analysis (мультитаймфреймовый анализ)
  - Pattern recognition (распознавание паттернов)
  - Mean reversion с улучшенными фильтрами
  - Trend following с улучшенным entry timing
- Исследовать использование машинного обучения для генерации сигналов
- Рассмотреть ансамблевые методы (комбинация нескольких стратегий)

### 6.3 Разработка новых стратегий
- Создать прототипы новых стратегий на основе исследований
- Быстро протестировать на небольшом датасете
- Выбрать наиболее перспективные для полного бэктестирования
- Оптимизировать лучшие новые стратегии
- Провести walk-forward валидацию

### 6.4 Документирование процесса
- Создать документ с описанием протестированных стратегий и их результатов
- Ведение реестра стратегий с метриками производительности
- Отмечать причины отказа от стратегий

## Критерии успеха

- Profit Factor > 1.0 для хотя бы одной стратегии
- Recovery Factor ≥ 1.5 для успешных стратегий
- Ускорение оптимизации в 4-8 раз через параллелизацию CPU
- Поддержка GPU для ускорения вычислений (если доступно)
- Стабильность параметров в walk-forward валидации (деградация < 30%)
- Визуализация всех сделок на графике с отображением динамических стоп-лоссов и тейк-профитов
- Возможность анализа сделок через интерактивные графики

